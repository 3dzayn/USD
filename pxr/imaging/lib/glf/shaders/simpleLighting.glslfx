-- glslfx version 0.1

//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

--- This is what an import might look like.
--- #import $TOOLS/glos/shaders/simpleLighting.glslfx
--- #import /user/anim/global/shaders/simpleLighting.glslfx

-- glsl SimpleLighting.GeometryInjection
#ifndef NUM_LIGHTS
#define NUM_LIGHTS 0
#endif

#if NUM_LIGHTS == 0

#else  // NUM_LIGHTS == 0

struct ShadowMatrix {
    mat4 viewToShadowMatrix;
    vec4 basis0;
    vec4 basis1;
    vec4 basis2;
    // Bias is generally negative
    float bias;
    // All these values should be positive
    float radius;
    float near;
    float far;
    float left;
    float right;
    float top;
    float bottom;
};

layout(std140) uniform Shadow {
    ShadowMatrix shadow[NUM_LIGHTS];
};

out vec2 FshadowFilterWidth[NUM_LIGHTS];

void
computeShadowFilterWidth(vec4 Peye)
{
    // interpolate filter width
    for (int i = 0; i < NUM_LIGHTS; ++i) {
        vec4 cx = shadow[i].basis0;
        vec4 cy = shadow[i].basis1;
        vec4 cz = shadow[i].basis2;
        
        // compare homogeneous vector length
        vec3 x = cx.xyz - cx.w * Peye.xyz;
        vec3 y = cy.xyz - cy.w * Peye.xyz;
        vec3 z = cz.xyz - cz.w * Peye.xyz;
        FshadowFilterWidth[i] = vec2(sqrt (1.0 / dot (x,x)), sqrt(1.0 / dot (y,y)));
    }
}

#define COMPUTE_SHADOW_FILTER_WIDTH 1

#endif  // NUM_LIGHTS == 0

-- glsl SimpleLighting.LightIntegrator

// ---------------------------------------------------------------------------
// struct definitions
// ---------------------------------------------------------------------------
#ifndef NUM_LIGHTS
#define NUM_LIGHTS 0
#endif

#ifndef HD_HAS_integrateLights
#define HD_HAS_integrateLights
#endif

#ifndef USE_PCSS
#define USE_PCSS 1
#endif

#ifndef PCSS_USE_POISSON
#define PCSS_USE_POISSON 1
#endif

struct LightSource {
    vec4 position;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 spotDirection;
    vec4 spotCutoffAndFalloff;
    vec4 attenuation;
    bool hasShadow;
    int shadowIndex;
    bool isIndirectLight;
    int padding0;
};

struct ShadowMatrix {
    mat4 viewToShadowMatrix;
    vec4 basis0;
    vec4 basis1;
    vec4 basis2;
    // Bias is generally negative
    float bias;
    // All these values should be positive
    float radius;
    float near;
    float far;
    float left;
    float right;
    float top;
    float bottom;
};

struct LightingContribution {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

struct LightingInterfaceProperties {
    float shininess;
};

// ---------------------------------------------------------------------------
// uniform blocks
// ---------------------------------------------------------------------------
#if NUM_LIGHTS == 0

#else  // NUM_LIGHTS == 0

layout(std140) uniform Lighting {
    bool useLighting;
    bool useColorMaterialDiffuse;
    LightSource lightSource[NUM_LIGHTS];
};

layout(std140) uniform Shadow {
    ShadowMatrix shadow[NUM_LIGHTS];
};


#endif  // NUM_LIGHTS == 0

// ---------------------------------------------------------------------------
// textures
// ---------------------------------------------------------------------------
uniform sampler2DArray shadowTexture;
uniform sampler2DArrayShadow shadowCompareTexture;

// ---------------------------------------------------------------------------
// lighting functions
// ---------------------------------------------------------------------------

#if NUM_LIGHTS == 0

LightingContribution
integrateLightsConstant(vec4 Peye, vec3 Neye, LightingInterfaceProperties props)
{
    LightingContribution result;
    result.ambient = vec3(0.0);
    //pefectly diffuse white hemisphere contribution
    result.diffuse = vec3(1.0);
    result.specular = vec3(0.0);

    return result;
}

LightingContribution
integrateLightsDefault(vec4 Peye, vec3 Neye, LightingInterfaceProperties props)
{
    return integrateLightsConstant(Peye, Neye, props);
}

#else // NUM_LIGHTS == 0

// shadowSample() returns depth value.
float
shadowSample(int index, vec2 uv)
{
    return texture(shadowTexture, vec3(uv, index)).z;
}

float
shadowCompare(int index, vec3 uvz)
{
    return texture(shadowCompareTexture,
                   vec4(uvz.xy, index, uvz.z));
}

#ifndef SHADOW_FILTER
float
shadowFilter(int index, vec3 uvz, vec4 Peye)
{
    return shadowCompare(index, uvz);
}
#endif


#if USE_PCSS

// We will search this many steps on each side, plus one "in the middle",
// for a total of NUM_BLOCKER_SEARCH_SAMPLES * 2 + 1 steps in each of XY
#define NUM_BLOCKER_SEARCH_SAMPLES 3

// Translate light XYs - generally somewhere in (left, right) / (bottom, top) -
// to shadow UVs - which are in (0, 1) range
vec2 LightXYToShadowUV(int index, vec2 lightXY)
{
    vec2 nearDim = vec2(shadow[index].right - shadow[index].left,
        shadow[index].top - shadow[index].bottom);
    return lightXY / nearDim;
}

// Translate a point in light XYZ space - generally somewhere in (left, right)
// (bottom, top) / (-near, -far) - to shadow UVs - which are in (0, 1) range
// Note that, though in light space the Z coordinate should strictly be negative,
// we assume here that it's positive
vec2 LightXYZToShadowUV(int index, vec3 lightXYZ)
{
    return LightXYToShadowUV(index, lightXYZ.xy * (shadow[index].near / lightXYZ.z));
}

// Calculate the size of the region to search, in shadow UV space (0 to 1),
// for the blocker
// Calculated based on triangle ratios:
//    searchSize / (zReceiver - near) == radius / zReceiver
vec2 BlockerSearchSizeUV(int index, float zReceiver)
{
    vec2 lightXY = vec2(shadow[index].radius) * (zReceiver - shadow[index].near) / zReceiver;
    return clamp(LightXYToShadowUV(index, lightXY), 0.0, .5);
}

// Calculate the size of shadow filter, in shadow UV space (0 to 1),
// based on the percentage-closer-soft-shadowing ratio of:
//    filterSize / (zReceiver - zBlocker) == radius / zBlocker
vec2 PCSSFilterSize(int index, float zReceiver, float zBlocker)
{
    vec3 lightXYZ = vec3(vec2(shadow[index].radius) * (zReceiver - zBlocker) / zBlocker,
                         zReceiver);
    return LightXYZToShadowUV(index, lightXYZ);
}

float ZShadowToZLight(int index, float zShadow)
{
    float zNDC = zShadow * 2.0 - 1.0;
    float far = shadow[index].far;
    float near = shadow[index].near;
    return 2 * far * near / ( (far - near) * zNDC - far - near);
}

#if PCSS_USE_POISSON

vec2 poissonCircle16[16] = vec2[] (
    vec2(-0.4861386999911106, -0.8131017515698877),
    vec2(-0.1379418757526687, -0.615688199407407),
    vec2(-0.7564435654127604, -0.4784037191192021),
    vec2(-0.3589654315656421, -0.20100347630994497),
    vec2(0.14915414784025227, -0.2591274969466977),
    vec2(0.576191505150637, -0.35634542228785826),
    vec2(-0.8396598211188767, -0.03177255032506765),
    vec2(-0.03149354030526419, 0.061258513133836345),
    vec2(0.3048306955444662, 0.1445404519033291),
    vec2(0.7678050733274815, 0.0771602092932755),
    vec2(-0.9504236693518691, 0.30329165751818943),
    vec2(-0.4886426883795304, 0.3260041612432061),
    vec2(-0.6843564597722496, 0.6891387513886138),
    vec2(-0.21954418320701996, 0.5975522182405921),
    vec2(0.3026461552247486, 0.6521013441018921),
    vec2(-0.13475166555549078, 0.917862124778025)
);

#endif // PCSS_USE_POISSON

// Returns average blocker depth in the search region, as well as the number of found blockers.
// Blockers are defined as shadow-map samples between the surface point and the light.
// receiverPt is in (0,1) shadow space
void FindBlocker(out float avgBlockerDepth, out float numBlockers,
                int index, vec3 receiverPt, vec2 blockerSearchSizeUV)
{
    float blockerSum = 0;
    numBlockers = 0;

#if PCSS_USE_POISSON

    for( int i = 0; i < poissonCircle16.length(); ++i )
    {
        vec2 offset = poissonCircle16[i] * blockerSearchSizeUV;
        float shadowMapDepth = shadowSample(index, receiverPt.xy + offset);
        // TODO: come up with a better bias method
        float zBiased = receiverPt.z + shadow[index].bias;
        if ( shadowMapDepth < zBiased )
        {
            blockerSum += shadowMapDepth;
            numBlockers++;
        }
    }

#else // PCSS_USE_POISSON
    vec2 stepUV = blockerSearchSizeUV / NUM_BLOCKER_SEARCH_SAMPLES;
    for( float x = -NUM_BLOCKER_SEARCH_SAMPLES; x <= NUM_BLOCKER_SEARCH_SAMPLES; ++x )
    {
        for( float y = -NUM_BLOCKER_SEARCH_SAMPLES; y <= NUM_BLOCKER_SEARCH_SAMPLES; ++y )
        {
            vec2 offset = vec2( x, y ) * stepUV;
            float shadowMapDepth = shadowSample(index, receiverPt.xy + offset);
            // TODO: come up with a better bias method
            float zBiased = receiverPt.z + shadow[index].bias;
            if ( shadowMapDepth < zBiased )
            {
                blockerSum += shadowMapDepth;
                numBlockers++;
            }
        }
    }

#endif // PCSS_USE_POISSON

    avgBlockerDepth = blockerSum / numBlockers;
}

vec2
computeShadowFilterWidth(int index, vec4 Peye)
{
    vec4 coord = shadow[index].viewToShadowMatrix * Peye;

    vec3 uvz = coord.xyz / coord.w;

    // Find blocking pts
    float avgBlockerDepth = 0;
    float numBlockers = 0;
    vec2 blockerSearchSizeUV = BlockerSearchSizeUV(index, coord.w);
    FindBlocker(avgBlockerDepth, numBlockers, index, uvz, blockerSearchSizeUV );

    // Quit if no blockers
    if (numBlockers == 0) return vec2(0.0);

    // Calculate the filter size based on relative blocker / receiver depths
    float avgBlockerDepthLight = -ZShadowToZLight(index, avgBlockerDepth);
    return PCSSFilterSize(index, coord.w, avgBlockerDepthLight);
}

#else // USE_PCSS

vec2
computeShadowFilterWidth(int index, vec4 Peye)
{
    vec4 cx = shadow[index].basis0;
    vec4 cy = shadow[index].basis1;
    vec4 cz = shadow[index].basis2;

    // compare homogeneous vector length
    vec3 x = cx.xyz - cx.w * Peye.xyz;
    vec3 y = cy.xyz - cy.w * Peye.xyz;
    vec3 z = cz.xyz - cz.w * Peye.xyz;
    return vec2(sqrt (1.0 / dot (x,x)), sqrt(1.0 / dot (y,y)));
}


#endif // USE_PCSS


float
shadowing(int index, vec4 Peye, float slope)
{
    float result = 1.0;
    vec4 coord = shadow[index].viewToShadowMatrix * Peye;

    // clamping at 1 because zero bias results in self shadowing, and
    // clamping at 2 to avoid shadows from dissapearing as angle gets very steep.
    slope = clamp(slope, 1.0, 2.0);

    // coord.xy : homogenous shadow uv coordinate
    // coord.z / coord.w : non-linear NDC "depth": -1 at near to 1 at far
    // coord.w : z-depth cordinate of shadow receiver, from light
    coord /= coord.w;
    coord.z = min(1, coord.z + (shadow[index].bias * slope));
    return shadowFilter(index, coord.xyz, Peye);
}

float
lightDistanceAttenuation(vec4 Peye, int index)
{
    float distAtten = 1.0;
    if (lightSource[index].position.w != 0.0) {
        float d = distance(lightSource[index].position, Peye);
        distAtten = 1.0 / (lightSource[index].attenuation[0] +
                           lightSource[index].attenuation[1] * d +
                           lightSource[index].attenuation[2] * d*d);
    }
    return distAtten;
}

float
lightSpotAttenuation(vec3 l, int index)
{
    float spotAtten = 1.0;
    if (lightSource[index].spotCutoffAndFalloff.x < 180.0) {
        float cosLight = dot(-l, lightSource[index].spotDirection.xyz);
        spotAtten = (cosLight < cos(radians(lightSource[index].spotCutoffAndFalloff.x)))
                ? 0.0 : pow(cosLight, lightSource[index].spotCutoffAndFalloff.y);
    }
    return spotAtten;
}

// for the comaptibility, turn on shadowing by default.
#ifndef USE_SHADOWS
#define USE_SHADOWS 1
#endif

LightingContribution
integrateLightsDefault(vec4 Peye, vec3 Neye, LightingInterfaceProperties props)
{
    LightingContribution result;
    result.ambient = vec3(0);
    result.diffuse = vec3(0);
    result.specular = vec3(0);
    
    vec3 n = normalize(Neye);
    vec3 e = normalize(-Peye.xyz);

    float shininess = props.shininess;
    
    for (int i = 0; i < NUM_LIGHTS; ++i) {

        vec4 Plight = lightSource[i].position;

        vec3 l = (Plight.w == 0.0)
                    ? normalize(Plight.xyz)
                    : normalize(Plight - Peye).xyz;

        vec3 h = normalize(l + vec3(0,0,1));    // directional viewer

        //cosine of incident angle of lightn
        float NdotL = max(0.0, dot(n, l));
        
        //cosine of incident angle from halfway vector between the eye and the light
        float NdotH = max(0.0, dot(n, h));

        //Lambert
        float d = NdotL;

        //Blinn-Phong
        float s = pow(NdotH, shininess);

        float atten = lightDistanceAttenuation(Peye, i);
        atten *= lightSpotAttenuation(l, i);

#if USE_SHADOWS
        // slope factor of fragment from the perspective of light
        float slope = tan(acos(NdotL));
        float shadow = (lightSource[i].hasShadow) ?
            shadowing(lightSource[i].shadowIndex, Peye, slope) : 1.0;
#else
        float shadow = 1.0;
#endif
        result.ambient += atten * lightSource[i].ambient.rgb;
        result.diffuse += atten * shadow * d * lightSource[i].diffuse.rgb;
        result.specular += atten * shadow * s * lightSource[i].specular.rgb;
    }

    return result;
}

LightingContribution
integrateLightsConstant(vec4 Peye, vec3 Neye, LightingInterfaceProperties props)
{
    LightingContribution result;
    result.ambient = vec3(0);
    result.specular = vec3(0);
    result.diffuse = vec3(1);

    return result;
}

#endif // NUM_LIGHTS == 0

-- glsl SimpleLighting.SimpleLighting

// ---------------------------------------------------------------------------
// struct definitions
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// uniform blocks
// ---------------------------------------------------------------------------

layout(std140) uniform Material {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 emission;
    vec4 sceneColor;
    float shininess;
} material;

// ---------------------------------------------------------------------------
// textures
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// lighting functions
// ---------------------------------------------------------------------------

#if NUM_LIGHTS == 0

vec4
simpleLighting(vec4 color, vec4 Peye, vec3 Neye, vec4 Ctint,
               vec4 matDiffuse, vec4 matAmbient, vec4 matSpecular, float matShininess)
{
    return color;
}

vec4
simpleLightingMaterial(vec4 color, vec4 Peye, vec3 Neye, vec4 Ctint)
{
    return material.emission + (material.sceneColor * material.ambient);
}

vec4
simpleLighting(vec4 color, vec4 Peye, vec3 Neye, vec4 Ctint)
{
    return simpleLightingMaterial(color, Peye, Neye, Ctint);
}

#else // NUM_LIGHTS == 0


LightingContribution
integrateLights(vec4 Peye, vec3 Neye, LightingInterfaceProperties props);

vec4
simpleLighting(vec4 color, vec4 Peye, vec3 Neye, vec4 Ctint,
               vec4 matDiffuse, vec4 matAmbient, vec4 matSpecular, float matShininess)
{

    // Get the roughness and metallic values

#if defined(HD_HAS_displayRoughness)
    float roughness = max(0.0, min(1.0, float(HdGet_displayRoughness())));
#else
    float roughness = 0.0;
#endif

#if defined(HD_HAS_displayMetallic)
    float metallic  = max(0.0, min(1.0, float(HdGet_displayMetallic())));
#else
    float metallic = 0.0;
#endif
    
    // determine the specular and diffuse intensity
    float Ks = (1.0 - roughness) + 2.0 * metallic;

    LightingInterfaceProperties props;

#if defined(HD_HAS_displayRoughness)
    float specularExp = (1.0 - roughness) * 120.0 + 8.0;
    props.shininess = specularExp;
    matSpecular.rgb = mix(vec3(1.0), matDiffuse.rgb, metallic);
#else
    props.shininess = matShininess;
#endif

    LightingContribution light = integrateLights(Peye, Neye, props);

    color.rgb += light.ambient * matAmbient.rgb;
    color.rgb += Ctint.rgb * light.diffuse * matDiffuse.rgb;
    color.rgb += Ks * light.specular * matSpecular.rgb;

    color.a = matDiffuse.a;

    return color;
}

vec4
simpleLightingMaterial(vec4 color, vec4 Peye, vec3 Neye, vec4 Ctint)
{
    // XXX todo: useColorMaterialDiffuse

    vec4 diffuse = color;
    vec4 ambient = material.ambient;
    vec4 specular = material.specular;
    float shininess = material.shininess;

    color = material.emission + (material.sceneColor * material.ambient);

    return simpleLighting(color, Peye, Neye, Ctint,
                          diffuse, ambient, specular, shininess);
}

vec4
simpleLighting(vec4 color, vec4 Peye, vec3 Neye, vec4 Ctint)
{
    return simpleLightingMaterial(color, Peye, Neye, Ctint);
}

#endif  // NUM_LIGHTS == 0
