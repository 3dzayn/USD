-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
            "fragmentShader": {
                "source": [ "OitResolve.Image" ]
            }
        }
    }
}

-- glsl OitResolve.Image

#ifdef OIT_ENABLE_APPROXIMATION

#define OSR OIT_STEP_FUNCTION_RESOLUTION

#endif

vec4 imageShader(vec2 uv)
{
#if defined(HD_HAS_hdxOitDataBuffer)
    int screenWidth = HdGet_oitWidth();
    int screenHeight = HdGet_oitHeight();
    int numSamples = HdGet_oitSamples();
    int bufferSize = screenWidth * screenHeight * numSamples;

    int screenIndex = int(gl_FragCoord.x) + int(gl_FragCoord.y) * screenWidth;
    int nodeIndex = hdxOitCounterBuffer[screenIndex+1];
#ifdef OIT_ENABLE_APPROXIMATION
    if (nodeIndex == -1) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    }

    //int layerCount = 0;
    //vec4 layerColor[OIT_LAYER_COUNT];
    //float layerDepth[OIT_LAYER_COUNT];
    //for (int id = nodeIndex; id != -1; id = hdxOitIndexBuffer[id]) {
    //    layerColor = hdxOitDataBuffer[id];
    //    layerDepth = hdxOitDepthBuffer[id];
    //    layerCount += 1;
    //}

    float nodeDepth[OSR];
    float nodeTrans[OSR];
    for (int id = 0; id < OSR; id += 1) {
        nodeDepth[id] = 1.0e30;
        nodeTrans[id] = 1.0;
    }
    int nodeCount = 0;

    for (int id = nodeIndex; id != -1; id = hdxOitIndexBuffer[id]) {
        float depth = hdxOitDepthBuffer[id];
        float trans = 1.0 - hdxOitDataBuffer[id].w;
        int insertIndex = 0;
        while (insertIndex < min(OSR, nodeCount) &&
               depth > nodeDepth[insertIndex]) {
            insertIndex += 1;
        }
        if (insertIndex == OSR) {
            continue;
        }

        for (int id = min(nodeCount, OSR) - 1; id > insertIndex; id -= 1) {
            nodeDepth[id] = nodeDepth[id - 1];
            nodeTrans[id] = nodeTrans[id - 1] * trans;
        }

        nodeDepth[insertIndex] = depth;
        nodeTrans[insertIndex] = trans;
        nodeCount += 1;
    }

    vec4 colorAccum = vec4(0.0, 0.0, 0.0, 0.0);
    for (int id = nodeIndex; id != -1; id = hdxOitIndexBuffer[id]) {
        float currentDepth = hdxOitDepthBuffer[id];
        vec4 currentSample = hdxOitDataBuffer[id];

        int closestIndex = 0;
        while (closestIndex < min(OSR, nodeCount) &&
               currentDepth > nodeDepth[closestIndex]) {
            closestIndex += 1;
        }

        if (closestIndex == 0) {
            colorAccum.xyz += currentSample.xyz * currentSample.w;
            colorAccum.a += currentSample.w;
        } else if (closestIndex < OSR) {
            colorAccum.xyz += currentSample.xyz * currentSample.w * nodeTrans[closestIndex];
            colorAccum.a += currentSample.w * nodeTrans[closestIndex];
        }

        colorAccum.a = clamp(colorAccum.a, 0.0, 1.0);
        if (colorAccum.a >= 0.999) {
            break;
        }
    }

    return colorAccum;
#else  // OIT_ENABLE_APPROXIMATION
    int numDepths = 0;

    // XXX renderPass.WriteOitLayersToBuffer does not clamp the number of
    //     depth samples we store for a pixel. Here we process no more than
    //     'OIT_LAYER_COUNT' for a pixel. (If there are greater than
    //     'OIT_LAYER_COUNT' samples stored for this pixel some will
    //     currently not contribute)
    vec4 sortedColor[OIT_LAYER_COUNT];
    float sortedDepth[OIT_LAYER_COUNT];

#if 1
    while (nodeIndex != -1 && numDepths < OIT_LAYER_COUNT) {
        sortedDepth[numDepths] = hdxOitDepthBuffer[nodeIndex];
        sortedColor[numDepths] = hdxOitDataBuffer[nodeIndex];
        nodeIndex = hdxOitIndexBuffer[nodeIndex];
        numDepths += 1;
    }

    float td;
    vec4 tc;
    for (int i = 0; i < numDepths - 1; i += 1) {
        int swap = i;
        for (int j = i + 1; j < numDepths; j += 1) {
            if (sortedDepth[swap] > sortedDepth[j]) {
                swap = j;
            }
        }
        td = sortedDepth[swap];
        tc = sortedColor[swap];

        sortedDepth[swap] = sortedDepth[i];
        sortedColor[swap] = sortedColor[i];

        sortedDepth[i] = td;
        sortedColor[i] = tc;
    }
#else
    while (nodeIndex != -1 && numDepths < OIT_LAYER_COUNT) {
        float currentDepth = hdxOitDepthBuffer[nodeIndex]; 
        int insertIndex = numDepths; 
        while (insertIndex > 0 && sortedDepth[insertIndex - 1] > currentDepth) {
            sortedDepth[insertIndex] = sortedDepth[insertIndex - 1];
            sortedColor[insertIndex] = sortedColor[insertIndex - 1]; 
            insertIndex -= 1; 
        }
        sortedColor[insertIndex] = hdxOitDataBuffer[nodeIndex];
        sortedDepth[insertIndex] = hdxOitDepthBuffer[nodeIndex];
        numDepths += 1; 
        nodeIndex = hdxOitIndexBuffer[nodeIndex]; 
    }
#endif
    int depth = 0;
    vec4 colorAccum = vec4(0,0,0,0);
    while (depth < numDepths) {
        vec4 cs = sortedColor[depth];
        float ca = cs.a * (1 - colorAccum.a);
        vec3 cb = cs.rgb;
        colorAccum.rgb = colorAccum.rgb + cb * ca;
        colorAccum.a = colorAccum.a + ca;

        colorAccum = clamp(colorAccum, vec4(0), vec4(1));
        if (colorAccum.a >= 0.99) break;

        depth += 1; 
    }

    return colorAccum;
#endif  // OIT_ENABLE_APPROXIMATION

#else  // HD_HAS_hdxOitDataBuffer
    return vec4(0);
#endif   // HD_HAS_hdxOitDataBuffer
}
