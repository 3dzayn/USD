-- glslfx version 0.1

//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

--- This is what an import might look like.
--- #import $TOOLS/hdx/shaders/renderPass.glslfx

-- glsl HdxRenderPass.ShouldCullFaceShadows

bool ShouldCullFace(bool frontFacing, bool doubleSided)
{
    const uint HdCullStyleDontCare               = uint(0);
    const uint HdCullStyleNothing                = uint(1);
    const uint HdCullStyleBack                   = uint(2);
    const uint HdCullStyleFront                  = uint(3);
    const uint HdCullStyleBackUnlessDoubleSided  = uint(4);
    const uint HdCullStyleFrontUnlessDoubleSided = uint(5);

#if defined(HD_HAS_cullStyle)
    uint cullStyle = HdGet_cullStyle();
#else
    uint cullStyle = HdCullStyleNothing;
#endif

    // Invert the cullstyle so we can render shadows correctly
    return ((cullStyle == HdCullStyleBack                   && frontFacing) ||
            (cullStyle == HdCullStyleFront                  && !frontFacing) ||
            (cullStyle == HdCullStyleBackUnlessDoubleSided  && frontFacing && !doubleSided) ||
            (cullStyle == HdCullStyleFrontUnlessDoubleSided && !frontFacing && !doubleSided));
}

-- glsl HdxRenderPass.RenderColorShadowsOutput

layout (location = 0) out vec4 colorOut;

vec4 ApplyColorOverrides(vec4 color)
{
    return color;
}

void RenderColor(vec4 color)
{
    colorOut = color;
}

--- --------------------------------------------------------------------------
-- glsl HdxRenderPass.RenderColorOutputWithSelection

#if defined(HD_HAS_hdxSelectionBuffer)
// helper methods to decode hdxSelectionBuffer
// ------ selection highlight mode specifics -------
bool HighlightModeHasSelection(int offset)
{
    return (offset != 0);
}

int GetIndexOffsetForHighlightMode(int mode)
{
    return hdxSelectionBuffer[mode + 1/*[0] holds #modes*/];
}

int GetNumSelectionHighlightModes()
{
    return hdxSelectionBuffer[0];
}

vec4 GetSelectionColor(int mode)
{
    vec4 s = vec4(0,0,0,0);
    // XXX: Make selection colors an array so we can avoid the branching.
    if (mode == 0)
        s = HdGet_selColor();
    else if (mode == 1)
        s = HdGet_selLocateColor();
    else if (mode == 2)
        s = HdGet_selMaskColor();

    return s;
}

// ------  selection offset specifics -------
// Note: This should match the selection offset encoding in
// hdx/SelectionTracker.cpp
void DecodeSelOffset(int selOffset, out bool isSelected, out int nextOffset)
{
    isSelected = bool(selOffset & 0x1); // bit 0
    nextOffset = selOffset >> 1;        // bits 31:1
}

// --------- subprim decoding ----------
// Each subprims offsets' buffer encoding is:
// [subprim-type][min][max][     selOffsets     ]
// <----------3 ----------><--- max - min + 1 -->
struct SubprimHeader {
    int type;
    int min;
    int max;
};
SubprimHeader DecodeSubprimHeader(int offset)
{
    SubprimHeader header;
    header.type = hdxSelectionBuffer[offset    ];
    header.min  = hdxSelectionBuffer[offset + 1];
    header.max  = hdxSelectionBuffer[offset + 2];
    return header;
}

bool IsSubprimSelected(int id, int min, int max, int headerStart,
                       out int nextSubprimOffset)
{
    const int SUBPRIM_SELOFFSETS_HEADER_SIZE  = 3;

    nextSubprimOffset = 0; // initialize
    bool isSelected = false;

    if (id >= min && id < max) {
        int netSubprimIndex =
            headerStart + SUBPRIM_SELOFFSETS_HEADER_SIZE + id - min;
        int selOffset = hdxSelectionBuffer[netSubprimIndex];

        DecodeSelOffset(selOffset, /*out*/isSelected, /*out*/nextSubprimOffset);
    } else {
        // The subprim id does not fall in the selected id range, so the subprim
        // in question isn't selected. However, we can still have other
        // subprim(s) selected. To get the offset to jump to, we mimic decoding
        // the "min" subprim id.
        int minSubprimIndex = headerStart + SUBPRIM_SELOFFSETS_HEADER_SIZE;
        DecodeSelOffset(hdxSelectionBuffer[minSubprimIndex],
                        /*out*/isSelected, /*out*/nextSubprimOffset);
        isSelected = false;
    }

    return isSelected;
}

struct SubprimSelectionResult {
    bool elementSelected;
    bool edgeSelected;
    bool pointSelected;
};
bool IsAnySubprimSelected(SubprimSelectionResult s)
{
    return (s.elementSelected || s.edgeSelected || s.pointSelected);
}

// Fwd declare helper fn defined in pointId.glslfx
int GetPointId();
// Fwd declare helper fn defined in edgeId.glslfx, or generated via codeGen
int GetPrimitiveEdgeId();
// Note: These should match the SubprimType enum in hdx/SelectionTracker.cpp
#define SUBPRIM_TYPE_ELEMENT 0
#define SUBPRIM_TYPE_EDGE    1
#define SUBPRIM_TYPE_POINT   2
SubprimSelectionResult GetSubprimSel(int offset)
{
    SubprimSelectionResult s = SubprimSelectionResult(false, false, false);
    int nextSubprimOffset = 0;
    SubprimHeader header = DecodeSubprimHeader(offset);

    if (header.type == SUBPRIM_TYPE_ELEMENT) {
        int elementId = GetElementID();
        s.elementSelected =
            IsSubprimSelected(elementId, header.min, header.max,
                              offset, /*out*/nextSubprimOffset);

        if (nextSubprimOffset != 0) {
            // fragment has additional subprim(s) selected. update header.
            header = DecodeSubprimHeader(nextSubprimOffset);
            offset = nextSubprimOffset;
        }
    }

    if (header.type == SUBPRIM_TYPE_EDGE) {
        int edgeId = GetAuthoredEdgeId(GetPrimitiveEdgeId());
        s.edgeSelected =
            IsSubprimSelected(edgeId, header.min, header.max,
                              offset, /*out*/nextSubprimOffset);

        if (nextSubprimOffset != 0) {
            // fragment has points selected. update header.
            header = DecodeSubprimHeader(nextSubprimOffset);
            offset = nextSubprimOffset;
        }
    }

    if (header.type == SUBPRIM_TYPE_POINT) {
        int ptId = GetPointId();
        s.pointSelected =
            IsSubprimSelected(ptId, header.min, header.max,
                              offset, /*unused*/nextSubprimOffset);
    }

    return s;
}

// --------- instance decoding ----------
bool IsInstanceSelected(int offset, out int nextOffset)
{
    // if the prim doesn't have instances, we still want to check if any
    // subprim is highlighted.
    // so, initialize the nextOffset to offset (and not 0).
    nextOffset = offset;
    bool sel = false;

    #if defined(HD_INSTANCER_NUM_LEVELS) && HD_INSTANCER_NUM_LEVELS > 0
    const int INSTANCE_SELOFFSETS_HEADER_SIZE = 2;

    for (int level = 0; level < HD_INSTANCER_NUM_LEVELS; level++) {
        int min = hdxSelectionBuffer[offset  ];
        int max = hdxSelectionBuffer[offset+1];
        // allow to highlight in a top-down manner, by flipping level
        // during iteration.
        // note: instanceIndex[0] is instanceID.
        //       instanceIndex for level n is stored at instanceIndex[n+1]
        int instanceId =
            GetDrawingCoord().instanceIndex[HD_INSTANCER_NUM_LEVELS-level];

        if (instanceId >= min && instanceId < max) {
            int netIndex = offset + INSTANCE_SELOFFSETS_HEADER_SIZE +
                           instanceId - min;
            DecodeSelOffset(hdxSelectionBuffer[netIndex],
                            /*out*/sel, /*out*/nextOffset);
            if (sel) break;
            if (!sel && nextOffset == 0) break;

            // at this point, we need to traverse other levels to figure out
            // if this instance is selected.
            offset = nextOffset;
        } else { // instanceId not in range
            break;
        }
    }
    #endif

    return sel;
}
#endif // HD_HAS_hdxSelectionBuffer

vec4 ApplySelectionColor(vec4 color)
{
#if defined(HD_HAS_hdxSelectionBuffer)
    const int primId = HdGet_primID();
    const int numSelectionModes = GetNumSelectionHighlightModes();
    // The hdxSelectionBuffer layout is:
    // [#modes] [per-mode offset] [data mode0] ... [data modeM]
    // [---------header---------]
    // Each mode's data is laid out as:
    // [ prims | points | edges | elements | instance level-N | ... | level 0 ]
    //          <-------- subprims ------->  <----------- instances --------->
    //          <---------------------- per prim ---------------------------->
    // See hdx/SelectionTracker.cpp for details on the encoding scheme.

    for (int mode = 0; mode < numSelectionModes; mode++) {
        int modeOffset = GetIndexOffsetForHighlightMode(mode);
        if (!HighlightModeHasSelection(modeOffset)) {
            // highlight mode has no objects (prims/instances/elements)
            continue;
        }

        const int PRIM_SELOFFSETS_HEADER_SIZE = 2;
        int smin = hdxSelectionBuffer[modeOffset];
        int smax = hdxSelectionBuffer[modeOffset + 1];
        bool sel = false;
        SubprimSelectionResult subprimSel =
            SubprimSelectionResult(false, false, false);

        if (primId >= smin && primId < smax) {
            int offset = modeOffset + PRIM_SELOFFSETS_HEADER_SIZE + primId - smin;
            int nextOffset = 0;
            DecodeSelOffset(hdxSelectionBuffer[offset],
                            /*out*/sel, /*out*/nextOffset);

            // At this point, sel indicates whether the fragment corresponds to
            // a prim that needs to be fully highlighted, while a non-zero
            // nextOffset indicates whether additional decoding may be done.

            // We don't currently differentiate between prim, instance and
            // subprim selection highlighting (i.e., visually, they look the
            // same), and thus can skip additional decoding if sel is true.
            // We choose not to, for ease of future customization.
            if (nextOffset != 0) {
                // check if instance (or) subprim(s) are selected
                offset = nextOffset;
                sel = sel || IsInstanceSelected(offset, /*out*/nextOffset);

                if (nextOffset != 0) {
                    subprimSel = GetSubprimSel(nextOffset);
                }
            }

            if (sel || IsAnySubprimSelected(subprimSel)) {
                // XXX: Since we don't support subprim specific selection color,
                // we simply use the mode to get the color to use.
                // Once we plumb subprim selection colors, it makes sense to
                // apply the "prim" selection color first, and then subprim(s).
                vec4 s = GetSelectionColor(mode);

                // Note: We blend mask (over) locate (over) select when an
                // object is in all three highlight modes.
                color.rgb = mix(color.rgb, s.rgb, s.a);
            }
        } // primId in range
    } // for each highlight mode
    
#endif
    return color;
}

vec4 ApplyColorOverrides(vec4 color)
{
#if defined(HD_HAS_scalarOverride)
    // Allow a scalar value to override the color from the surface
    // for previewing heatmaps. This is useful for editing workflows.
#if defined(HD_HAS_scalarOverrideColorRamp)
    int rampCount = constantPrimvars[GetDrawingCoord().constantCoord].
                scalarOverrideColorRamp.length();
    float scalar = HdGet_scalarOverride() * float(rampCount - 1);
    float baseIndex = floor(scalar);
    float nextIndex = min(float(rampCount - 1), baseIndex + 1.0);
    float interp = scalar - baseIndex;
    color = mix(HdGet_scalarOverrideColorRamp(int(baseIndex)),
                HdGet_scalarOverrideColorRamp(int(nextIndex)),
                interp);
#else
    // If no ramp is given just gamma correct the scalar as greyscale.
    color.rgb = vec3(pow(HdGet_scalarOverride(), 2.2));
#endif // HD_HAS_scalarOverrideColorRamp

#elif defined(HD_HAS_overrideColor)
    // Mix in override color
    vec4 overrideColor = HdGet_overrideColor();
    color.rgb = mix(color.rgb, overrideColor.rgb, overrideColor.a);
#endif
    return ApplySelectionColor(color);
}

layout (location = 0) out vec4 colorOut;

void RenderColor(vec4 color)
{
    colorOut = color;
}

--- --------------------------------------------------------------------------
-- glsl HdxRenderPass.RenderColorIdOutput

layout (location = 0) out vec4 primIdOut;
layout (location = 1) out vec4 instanceIdOut;
layout (location = 2) out vec4 elementIdOut;
layout (location = 3) out vec4 edgeIdOut;
layout (location = 4) out vec4 pointIdOut;

// Forward declare relevant helper functions that are defined in
// hdSt/shaders/edgeId.glslfx (or) generated via code gen.
int GetPrimitiveEdgeId();
bool IsFragmentOnEdge();
int GetPointId();
bool IsFragmentOnPoint();

vec4 ApplyColorOverrides(vec4 color)
{
    // Don't apply overrides during ID render pass.
    return color;
}

vec4 IntToVec4(int id)
{
    return vec4(((id >>  0) & 0xff) / 255.0,
                ((id >>  8) & 0xff) / 255.0,
                ((id >> 16) & 0xff) / 255.0,
                ((id >> 24) & 0xff) / 255.0);
}

void RenderColor(vec4 color)
{
    int primId = HdGet_primID();
    primIdOut = IntToVec4(primId);

    // instanceIndex is a tuple of integers (num nested levels).
    // for picking, we store global instanceId (instanceIndex[0]) in the
    // selection framebuffer and then reconstruct the tuple in postprocess.
    int instanceId = GetDrawingCoord().instanceIndex[0];
    instanceIdOut = IntToVec4(instanceId);

    int elementId = GetElementID();
    elementIdOut = IntToVec4(elementId);

    {
        // XXX: This block should be under an #ifdef
        int edgeId = -1;
        if (IsFragmentOnEdge()) {
            edgeId = GetAuthoredEdgeId(GetPrimitiveEdgeId());
        }
        edgeIdOut = IntToVec4(edgeId);
    }

    {
        // XXX: This block should be under an #ifdef
        int pointId = -1;
        if (IsFragmentOnPoint()) {
            pointId = GetPointId();
        }
        pointIdOut = IntToVec4(pointId);
    }
    
}
